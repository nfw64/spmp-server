@file:Suppress("UNUSED_VARIABLE")

import org.jetbrains.kotlin.gradle.internal.ensureParentDirsCreated
import org.jetbrains.kotlin.gradle.plugin.mpp.KotlinNativeTargetWithHostTests
import java.io.PrintWriter
import java.io.ByteArrayOutputStream

val GENERATED_FILE_PREFIX = "// Generated on build in build.gradle.kts\n"

plugins {
    kotlin("multiplatform") version "1.9.10"
    kotlin("plugin.serialization") version "1.9.0"
}

repositories {
    mavenCentral()
    gradlePluginPortal()
}

val cinterop_libs: List<CInteropDefinition> = listOf(
    CInteropDefinition(
        "libmpv",
        "mpv",
        listOf("mpv/client.h")
    ),
    CInteropDefinition(
        "libzmq",
        "libzmq",
        listOf("zmq.h", "zmq_utils.h"),
        compiler_opts = listOf("-DZMQ_BUILD_DRAFT_API=1")
    ),
    CInteropDefinition(
        "libappindicator",
        "appindicator3-0.1",
        listOf("libappindicator3-0.1/libappindicator/app-indicator.h")
    )
)

kotlin {
    val native_target: KotlinNativeTargetWithHostTests = when (OS.current) {
        OS.LINUX -> linuxX64("native")
        OS.WINDOWS -> mingwX64("native")
        OS.OSX_X86 -> macosX64("native")
        OS.OSX_ARM -> macosArm64("native")
    }

    native_target.apply {
        compilations.getByName("main") {
            cinterops {
                for (lib in cinterop_libs) {
                    create(lib.name)
                }
            }
        }

        binaries {
            executable {
                entryPoint = "main"
            }
        }
    }

    sourceSets {
        val nativeMain by getting {
            dependencies {
                implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
                implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.5.1")
                implementation("com.github.ajalt.clikt:clikt:4.2.1")
                implementation("com.squareup.okio:okio:3.6.0")

                val ktor_version: String = "2.3.6"
                implementation("io.ktor:ktor-client-core:$ktor_version")
                implementation("io.ktor:ktor-client-curl:$ktor_version")
                implementation("io.ktor:ktor-server-core:$ktor_version")
                implementation("io.ktor:ktor-server-cio:$ktor_version")
            }
        }
    }
}

tasks.withType<Wrapper> {
    gradleVersion = "7.6"
    distributionType = Wrapper.DistributionType.BIN
}

tasks.register("bundleIcon") {
    val in_file: File = project.file("icon.png")
    inputs.file(in_file)

    val out_file: File = project.file("src/nativeMain/kotlin/Icon.gen.kt")
    outputs.file(out_file)

    doLast {
        check(in_file.isFile)

        out_file.writer().use { writer ->
            writer.write("${GENERATED_FILE_PREFIX}\n// https://youtrack.jetbrains.com/issue/KT-39194\n")
            writer.write("val ICON_BYTES: ByteArray = byteArrayOf(")

            val bytes: ByteArray = in_file.readBytes()
            for ((i, byte) in bytes.withIndex()) {
                if (byte >= 0) {
                    writer.write("0x${byte.toString(16)}")
                }
                else {
                    writer.write("-0x${byte.toString(16).substring(1)}")
                }

                if (i + 1 != bytes.size) {
                    writer.write(",")
                }
            }

            writer.write(")\n")
        }
    }
}

tasks.register("bundleGitCommitHash") {
    val out_file: File = project.file("src/nativeMain/kotlin/GitCommitHash.gen.kt")
    outputs.file(out_file)

    doLast {
        val git_commit_hash: String = getCurrentGitCommitHash()!!
        out_file.writeText("${GENERATED_FILE_PREFIX}val GIT_COMMIT_HASH: String = \"$git_commit_hash\"\n")
    }
}

tasks.getByName("compileKotlinNative") {
    dependsOn("bundleIcon")
    dependsOn("bundleGitCommitHash")
}

tasks.register("generateCInteropDefinitions") {
    doLast {
        val cinterop_directory: File = rootProject.file("src/nativeInterop/cinterop")

        for (lib in cinterop_libs) {
            val file: File = cinterop_directory.resolve(lib.name + ".def")
            file.ensureParentDirsCreated()
            file.createNewFile()

            file.printWriter().use { writer ->
                writer.println("# Automatically generated by build.gradle.kts")
                lib.writeTo(writer)
            }
        }
    }
}

for (lib in cinterop_libs) {
    val libname: String = lib.name.first().toUpperCase() + lib.name.drop(1)
    tasks.getByName("cinterop${libname}Native") {
        dependsOn("generateCInteropDefinitions")
    }
}

enum class OS {
    LINUX, WINDOWS, OSX_X86, OSX_ARM;

    companion object {
        val current: OS get() {
            val host_os = System.getProperty("os.name")
            val arch: String = System.getProperty("os.arch")
            return when {
                host_os == "Linux" -> LINUX
                host_os.startsWith("Windows") -> WINDOWS
                host_os == "Mac OS X" && arch == "x86_64" -> OSX_X86
                host_os == "Mac OS X" && arch == "aarch64" -> OSX_ARM
                else -> throw GradleException("Host OS '$host_os' ($arch) is not supported by Kotlin/Native")
            }
        }
    }
}

data class CInteropDefinition(
    val name: String,
    val pkg: String,
    val headers: List<String>,
    val compiler_opts: List<String> = emptyList(),
    val linker_opts: List<String> = emptyList()
) {
    private fun PrintWriter.writeList(property: String, items: List<String>) {
        if (items.isNotEmpty()) {
            print("$property =")
            for (header in items)  {
                print(' ')
                print(header)
            }
            print('\n')
        }
    }

    fun writeTo(writer: PrintWriter) {
        writer.writeList("headers", headers)
        writer.writeList("compilerOpts.linux", default_compileropts_linux + compiler_opts + pkgConfig(pkg, cflags = true))
        writer.writeList("linkerOpts.linux", default_linkeropts_linux + linker_opts + pkgConfig(pkg, libs = true))
    }

    companion object {
        private val default_compileropts_linux = listOf("-I/usr/include", "-I/usr/include/x86_64-linux-gnu")
        private val default_linkeropts_linux = listOf("-L/usr/lib", "-L/usr/lib/x86_64-linux-gnu")
    }
}

// https://gist.github.com/micolous/c00b14b2dc321fdb0eab8ad796d71b80
fun pkgConfig(
    vararg package_names: String,
    cflags: Boolean = false,
    libs: Boolean = false
): List<String> {
    require(cflags || libs)

    val process_builder: ProcessBuilder = ProcessBuilder(
        listOfNotNull(
            "pkg-config",
            if (cflags) "--cflags" else null,
            if (libs) "--libs" else null
        ) + package_names
    )
    process_builder.environment()["PKG_CONFIG_ALLOW_SYSTEM_LIBS"] = "1"

    val process: Process = process_builder.start()
    process.waitFor(10, TimeUnit.SECONDS)

    check(process.exitValue() == 0) {
        process.errorStream
        "pkg-config failed with package_names: ${package_names.toList()}\n" + process.errorStream.bufferedReader().use { it.readText() }
    }

    return process.inputStream.bufferedReader().use { reader ->
        reader.readText().split(" ").mapNotNull { it.trim().takeIf { it.isNotBlank() } }
    }
}

fun cmd(vararg args: String): String {
    val out = ByteArrayOutputStream()
    exec {
        commandLine(args.toList())
        standardOutput = out
    }
    return out.toString().trim()
}

fun getCurrentGitTag(): String? {
    try {
        return cmd("git", "tag", "--points-at", "HEAD").ifBlank { null }
    }
    catch (e: Throwable) {
        RuntimeException("Getting Git tag failed", e).printStackTrace()
        return null
    }
}

fun getCurrentGitCommitHash(): String? {
    try {
        return cmd("git", "rev-parse", "HEAD").ifBlank { null }
    }
    catch (e: Throwable) {
        RuntimeException("Getting Git commit hash failed", e).printStackTrace()
        return null
    }
}
